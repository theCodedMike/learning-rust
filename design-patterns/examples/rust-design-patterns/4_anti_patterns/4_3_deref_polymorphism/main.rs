//! ## Deref多态
//!
//! ### 描述
//! 滥用Deref特性，模拟结构体之间的继承，从而重用方法
//!
//! ### 优点
//! 节省了一些样板代码，例如：
//! ```rust
//! impl Bar {
//!     fn m(&self) {
//!         self.f.m()
//!     }
//! }
//! ```
//!
//! ### 缺点
//! 最重要的是这是一个令人惊讶的习惯用法——未来的程序员在阅读这些代码时不会期望发生这种情况
//!
//! 这种模式并没有实现像Java或者C++里的继承。此外，对Foo实现的特性也不会自动地适用于Boo，所以这种模式对于边界检查和泛型编程来说非常差
//!
//! 最后，这种模式仅支持单继承，并且没有接口的概念、基于类的隐私性或者其他的与继承相关的特性
//!
//! ### 讨论
//! 还没有好的替代方案
//!
//! Deref特性是被设计用来实现自定义指针类型的。它的用处是将T的引用转变为T的值，而不是在类型间转换
//!
//! ### 执行
//! cargo r --example 4_3
//!

use crate::model::{Bar, Foo};

mod model;

/// 有时我们想要从诸如Java之类的面向对象语言中模拟以下常见模式
///
/// ```rust
/// class Foo {
///     void m() { ... }
/// }
///
/// class Bar extends Foo {}
///
/// public static void main(String[] args) {
///     Bar b = new Bar();
///     b.m();
/// }
/// ```
fn main() {
    let b = Bar { f: Foo {} };
    b.m(); // foo
}
